# Auto-generated by EventBridge. DO NOT EDIT MANUALLY.
# This file will be overwritten each time 'Generate Registry' is used.

@tool
class_name EventBridgeManager
extends Node

var DEBUG := ProjectSettings.get_setting("event_bridge/debug")

var MainMenu: EventBusAutoload.Namespace
var Game: EventBusAutoload.Namespace

func _ready() -> void:
	MainMenu = EventBus.get_namespace("MainMenu")
	Game = EventBus.get_namespace("Game")

# --- Event API ---

## Event: MainMenu::send_test_message ---[br]
## Target: to_id | Mode: any_peer | Sync: call_remote | Transfer: reliable | Channel: 0 [br][br]
## Usage (emit): [br]
##     EventManager.mainmenu_send_test_message(message, peer_id)
func mainmenu_send_test_message(message: String, peer_id: int) -> void:
	MainMenu.to_id(peer_id, "send_test_message", [message])

# Subscribe with callback signature: func(message: String) -> void
## Usage (subscribe):[br]
##     var cb := func(message: String) -> void:
##     EventManager.on_mainmenu_send_test_message(cb)[br]
##     [br]Later, to unsubscribe (keep the same Callable reference):[br]
##     EventManager.off_mainmenu_send_test_message(cb)
##     [br][br]One-liner subscribe example:[br]
##     EventManager.on_mainmenu_send_test_message(func(message: String) -> void: print("mainmenu_send_test_message:", message))[br]
func on_mainmenu_send_test_message(callback: Callable) -> void:
	MainMenu.on("send_test_message", callback)

# Unsubscribe the same Callable you used in on_mainmenu_send_test_message
func off_mainmenu_send_test_message(callback: Callable) -> void:
	MainMenu.off("send_test_message", callback)

## Event: Game::report_score ---[br]
## Target: to_server | Mode: authority | Sync: call_local | Transfer: reliable | Channel: 0 [br][br]
## Usage (emit): [br]
##     EventManager.game_report_score(scores)
func game_report_score(scores: Dictionary) -> void:
	Game.to_server("report_score", [scores])

# Subscribe with callback signature: func(scores: Dictionary) -> void
## Usage (subscribe):[br]
##     var cb := func(scores: Dictionary) -> void:
##     EventManager.on_game_report_score(cb)[br]
##     [br]Later, to unsubscribe (keep the same Callable reference):[br]
##     EventManager.off_game_report_score(cb)
##     [br][br]One-liner subscribe example:[br]
##     EventManager.on_game_report_score(func(scores: Dictionary) -> void: print("game_report_score:", scores))[br]
func on_game_report_score(callback: Callable) -> void:
	Game.on("report_score", callback)

# Unsubscribe the same Callable you used in on_game_report_score
func off_game_report_score(callback: Callable) -> void:
	Game.off("report_score", callback)

## Event: Game::game_over ---[br]
## Target: to_server | Mode: authority | Sync: call_remote | Transfer: reliable | Channel: 0 [br][br]
## Usage (emit): [br]
##     EventManager.game_game_over(winning_player_name, final_scores)
func game_game_over(winning_player_name: String, final_scores: Dictionary) -> void:
	Game.to_server("game_over", [winning_player_name, final_scores])

# Subscribe with callback signature: func(winning_player_name: String, final_scores: Dictionary) -> void
## Usage (subscribe):[br]
##     var cb := func(winning_player_name: String, final_scores: Dictionary) -> void:
##     EventManager.on_game_game_over(cb)[br]
##     [br]Later, to unsubscribe (keep the same Callable reference):[br]
##     EventManager.off_game_game_over(cb)
##     [br][br]One-liner subscribe example:[br]
##     EventManager.on_game_game_over(func(winning_player_name: String, final_scores: Dictionary) -> void: print("game_game_over:", winning_player_name, final_scores))[br]
func on_game_game_over(callback: Callable) -> void:
	Game.on("game_over", callback)

# Unsubscribe the same Callable you used in on_game_game_over
func off_game_game_over(callback: Callable) -> void:
	Game.off("game_over", callback)

## Event: Game::play_again ---[br]
## Target: to_server | Mode: authority | Sync: call_local | Transfer: reliable | Channel: 0 [br][br]
## Usage (emit): [br]
##     EventManager.game_play_again()
func game_play_again() -> void:
	Game.to_server("play_again", [])

# Subscribe with callback signature: func() -> void
## Usage (subscribe):[br]
##     var cb := func() -> void:
##     EventManager.on_game_play_again(cb)[br]
##     [br]Later, to unsubscribe (keep the same Callable reference):[br]
##     EventManager.off_game_play_again(cb)
##     [br][br]One-liner subscribe example:[br]
##     EventManager.on_game_play_again(func() -> void: print("game_play_again fired"))[br]
func on_game_play_again(callback: Callable) -> void:
	Game.on("play_again", callback)

# Unsubscribe the same Callable you used in on_game_play_again
func off_game_play_again(callback: Callable) -> void:
	Game.off("play_again", callback)

# --- Disconnect all handlers across all namespaces ---
func off_all() -> void:
	for ns in ["MainMenu", "Game"]:
		if get(ns) != null:
			get(ns).off_all()

# --- Disconnect all handlers for a specific namespace ---
func off_namespace(ns_name: String) -> void:
	if get(ns_name) != null:
		get(ns_name).off_all()

# --- Namespace-specific disconnect helpers ---
func off_MainMenu() -> void:
	if MainMenu != null:
		MainMenu.off_all()
func off_Game() -> void:
	if Game != null:
		Game.off_all()

# --- Validator Handling ---
func _validate_event(event_name: String, args: Array) -> bool:
	if DEBUG:
		EventBridgeLogger.event_log(str(self), "Fired for: %s with args: %s" % [event_name, args], 3)

	var validator_name = "validate_" + event_name
	if not has_method(validator_name):
		return true

	var method_info = get_method_list().filter(func(m): return m.name == validator_name)
	if method_info.is_empty():
		push_warning("Validator method '%s' not found in method list, but has_method returned true." % validator_name)
		return false

	var method = method_info[0]
	var result = true

	var expects_array = (
		method.args.size() == 1
		and method.args[0].type == TYPE_ARRAY
	)

	if expects_array:
		result = call(validator_name, args)
	else:
		if method.args.size() != args.size():
			push_warning("Validator '%s' expected %d arguments but got %d: %s" % [
				validator_name,
				method.args.size(),
				args.size(),
				args
			])
			return false
		var c := Callable(self, validator_name)
		var result_variant = c.callv(args)
		if result_variant == null:
			push_warning("Validator '%s' callv returned null with args: %s" % [validator_name, args])
			return false
		result = result_variant

	if not result:
		push_warning("Validation failed for event '%s'. Ignored." % event_name)
		return false

	return true
